{"version":3,"sources":["components/UI/Card.js","components/Expenses/ExpenseDate.js","components/Expenses/ExpenseItem.js","components/Expenses/ExpensesFilter.js","components/Expenses/ExpensesList.js","components/Chart/ChartBar.js","components/Chart/Chart.js","components/Expenses/ExpensesChart.js","components/Expenses/Expenses.js","components/NewExpense/ExpenseForm.js","components/NewExpense/NewExpense.js","App.js","index.js"],"names":["Card","props","classes","className","children","ExpenseDate","month","date","toLocaleString","day","year","getFullYear","ExpenseItem","title","amount","ExpensesFilter","value","selected","onChange","event","console","log","target","onChangeFilter","ExpensesList","items","length","map","i","id","ChartBar","barFillHeight","maxValue","Math","round","style","height","label","Chart","dataPointValues","dataPoints","dataPoint","totalMax","max","ExpensesChart","chartDataPoints","expenses","expense","getMonth","Expenses","useState","filteredYear","setFilteredYear","filteredExpenses","itemData","filter","toString","selectedYear","ExpenseForm","enteredTitle","setEnteredTitle","enteredAmount","setEnteredAmount","enteredDate","setEnteredDate","onSubmit","preventDefault","expenseData","Date","onSaveExpenseData","type","min","step","NewExpense","enteredExpenseDataPlaceHolder","random","onAddExpense","Dummy_Expenses","App","setExpenses","placeHolderItem","prevSnapshot","ReactDOM","render","document","getElementById"],"mappings":"4ZAUeA,MANf,SAAcC,GACb,IAAMC,EAAU,QAAUD,EAAME,UAEhC,OAAO,qBAAKA,UAAWD,EAAhB,SAA0BD,EAAMG,Y,YCUzBC,MAff,SAAqBJ,GACpB,IAAMK,EAAQL,EAAMM,KAAKC,eAAe,QAAS,CAAEF,MAAO,SAEpDG,EAAMR,EAAMM,KAAKC,eAAe,QAAS,CAAEC,IAAK,YAChDC,EAAOT,EAAMM,KAAKI,cAExB,OACC,sBAAKR,UAAU,eAAf,UACC,qBAAKA,UAAU,sBAAf,SAAsCG,IACtC,qBAAKH,UAAU,oBAAf,SAAoCM,IACpC,qBAAKN,UAAU,qBAAf,SAAqCO,QCOzBE,EAdK,SAACX,GACpB,OACC,qCACC,eAAC,EAAD,CAAME,UAAU,eAAhB,UACC,cAAC,EAAD,CAAaI,KAAMN,EAAMM,OACzB,qBAAKJ,UAAU,4BAAf,SACC,6BAAKF,EAAMY,UAEZ,sBAAKV,UAAU,sBAAf,cAAuCF,EAAMa,iBCYlCC,G,MArBQ,SAACd,GAMvB,OACC,qBAAKE,UAAU,kBAAf,SACC,sBAAKA,UAAU,2BAAf,UACC,mDACA,yBAAQa,MAAOf,EAAMgB,SAAUC,SATJ,SAACC,GAC9BC,QAAQC,IAAIF,EAAMG,OAAON,OACzBf,EAAMsB,eAAeJ,EAAMG,OAAON,QAOhC,UACC,wBAAQA,MAAM,OAAd,kBACA,wBAAQA,MAAM,OAAd,kBACA,wBAAQA,MAAM,OAAd,kBACA,wBAAQA,MAAM,OAAd,4BCQUQ,G,MAtBM,SAACvB,GAIlB,OAA2B,IAAvBA,EAAMwB,MAAMC,OACJ,oBAAIvB,UAAY,0BAAhB,+BAIL,qBAAIA,UAAU,gBAAd,gBACFF,EAAMwB,MAAME,KAAI,SAACC,GAAD,OACjB,cAAC,EAAD,CAEIf,MAAOe,EAAEf,MACTN,KAAMqB,EAAErB,KACRO,OAAQc,EAAEd,QAHLc,EAAEC,Y,OCMJC,G,YAnBE,SAAC7B,GACjB,IAAI8B,EAAgB,KAKpB,OAHI9B,EAAM+B,SAAW,IACpBD,EAAgBE,KAAKC,MAAOjC,EAAMe,MAAQf,EAAM+B,SAAY,KAAO,KAGnE,sBAAK7B,UAAU,YAAf,UACC,qBAAKA,UAAU,mBAAf,SACC,qBACCA,UAAU,kBACVgC,MAAO,CAAEC,OAAQL,OAGnB,qBAAK5B,UAAU,mBAAf,SAAmCF,EAAMoC,aCI7BC,EAjBD,SAACrC,GACd,IAAMsC,EAAkBtC,EAAMuC,WAAWb,KAAI,SAACc,GAAD,OAAeA,EAAUzB,SAChE0B,EAAWT,KAAKU,IAAL,MAAAV,KAAI,YAAQM,IAC7B,OACC,qBAAKpC,UAAU,QAAf,SACEF,EAAMuC,WAAWb,KAAI,SAACc,GAAD,OACrB,cAAC,EAAD,CAECzB,MAAOyB,EAAUzB,MACjBqB,MAAOI,EAAUJ,MACjBL,SAAUU,GAHLD,EAAUJ,aCoDLO,EA5DO,SAAC3C,GACtB,IADgC,EAC1B4C,EAAkB,CACvB,CACCR,MAAO,MACPrB,MAAO,GAER,CACCqB,MAAO,MACPrB,MAAO,GAER,CACCqB,MAAO,MACPrB,MAAO,GAER,CACCqB,MAAO,MACPrB,MAAO,GAER,CACCqB,MAAO,MACPrB,MAAO,GAER,CACCqB,MAAO,MACPrB,MAAO,GAER,CACCqB,MAAO,MACPrB,MAAO,GAER,CACCqB,MAAO,MACPrB,MAAO,GAER,CACCqB,MAAO,MACPrB,MAAO,GAER,CACCqB,MAAO,MACPrB,MAAO,GAER,CACCqB,MAAO,MACPrB,MAAO,GAER,CACCqB,MAAO,MACPrB,MAAO,IAhDuB,cAoDVf,EAAM6C,UApDI,IAoDhC,2BAAsC,CAAC,IAA5BC,EAA2B,QAErCF,EADqBE,EAAQxC,KAAKyC,YACJhC,OAAS+B,EAAQjC,QAtDhB,8BAyDhC,OAAO,cAAC,EAAD,CAAO0B,WAAYK,KCcZI,MAnEf,SAAkBhD,GACjB,MAAwCiD,mBAAS,QAAjD,mBAAOC,EAAP,KAAqBC,EAArB,KAQMC,EAAmBpD,EAAMqD,SAASC,QAAO,SAAC3B,GAC/C,OAAOA,EAAErB,KAAKI,cAAc6C,aAAeL,KAwB5C,OACC,8BACC,eAAC,EAAD,CAAMhD,UAAU,WAAhB,UACC,cAAC,EAAD,CACCc,SAAUkC,EACV5B,eApCwB,SAACkC,GAC5BL,EAAgBK,GAEhBrC,QAAQC,IAAIoC,MAqDV,cAAC,EAAD,CAAeX,SAAUO,IAExB,cAAC,EAAD,CAAc5B,MAAO4B,U,eCaXK,G,YA9EK,SAACzD,GACpB,MAAwCiD,mBAAS,IAAjD,mBAAOS,EAAP,KAAqBC,EAArB,KACA,EAA0CV,mBAAS,IAAnD,mBAAOW,EAAP,KAAsBC,EAAtB,KACA,EAAsCZ,mBAAS,IAA/C,mBAAOa,EAAP,KAAoBC,EAApB,KAiCA,OACC,8BACC,uBAAMC,SAlBc,SAAC9C,GACtBA,EAAM+C,iBAEN,IAAMC,EAAc,CACnBtD,MAAO8C,EACP7C,QAAS+C,EACTtD,KAAM,IAAI6D,KAAKL,IAEhB3C,QAAQC,IAAI8C,GACZlE,EAAMoE,kBAAkBF,GACxBP,EAAgB,IAChBE,EAAiB,IACjBE,EAAe,KAMd,UACC,sBAAK7D,UAAU,wBAAf,UACC,sBAAKA,UAAU,uBAAf,UACC,0CACA,uBACCmE,KAAK,OACLtD,MAAO2C,EACPzC,SAxCqB,SAACC,GAC3ByC,EAAgBzC,EAAMG,OAAON,OAC7BI,QAAQC,IAAIF,EAAMG,OAAON,aAyCtB,sBAAKb,UAAU,uBAAf,UACC,2CACA,uBACCmE,KAAK,SACLC,IAAI,OACJC,KAAK,OACLxD,MAAO6C,EACP3C,SA7CsB,SAACC,GAC5B2C,EAAiB3C,EAAMG,OAAON,OAC9BI,QAAQC,IAAIF,EAAMG,OAAON,aA8CtB,sBAAKb,UAAU,uBAAf,UACC,yCACA,uBACCmE,KAAK,OACLC,IAAI,aACJ5B,IAAI,aACJ3B,MAAO+C,EACP7C,SAnDoB,SAACC,GAC1B6C,EAAe7C,EAAMG,OAAON,gBAsD1B,qBAAKb,UAAU,uBAAf,SACC,wBAAQmE,KAAK,SAAb,mCCjDUG,EAlBI,SAACxE,GAUnB,OACC,qBAAKE,UAAU,cAAf,SACC,cAAC,EAAD,CAAakE,kBAXgB,SAACK,GAC/B,IAAMP,EAAW,2BACbO,GADa,IAEhB7C,GAAII,KAAK0C,SAASnB,aAEnBpC,QAAQC,IAAI8C,GACZlE,EAAM2E,aAAaT,SCRfU,EAAiB,CACtB,CACChD,GAAI,KACJhB,MAAO,eACPC,OAAQ,MACRP,KAAM,IAAI6D,KAAK,KAAM,EAAG,KAEzB,CAAEvC,GAAI,KAAMhB,MAAO,SAAUC,OAAQ,OAAQP,KAAM,IAAI6D,KAAK,KAAM,EAAG,KACrE,CACCvC,GAAI,KACJhB,MAAO,gBACPC,OAAQ,OACRP,KAAM,IAAI6D,KAAK,KAAM,EAAG,KAEzB,CACCvC,GAAI,KACJhB,MAAO,oBACPC,OAAQ,IACRP,KAAM,IAAI6D,KAAK,KAAM,EAAG,KAEzB,CACCvC,GAAI,KACJhB,MAAO,eACPC,OAAQ,KACRP,KAAM,IAAI6D,KAAK,KAAM,GAAI,MAsBZU,EAnBH,WACX,MAAgC5B,mBAAS2B,GAAzC,mBAAO/B,EAAP,KAAiBiC,EAAjB,KAQA,OACC,gCACC,cAAC,EAAD,CAAYH,aARY,SAACI,GAE1BD,GAAY,SAACE,GACZ,MAAM,CAAED,GAAR,mBAA4BC,UAM5B,qBAAK9E,UAAU,WAAf,SACC,cAAC,EAAD,CAAUmD,SAAUR,UCxCxBoC,IAASC,OAAO,cAAC,EAAD,IAASC,SAASC,eAAe,W","file":"static/js/main.06f0f5f5.chunk.js","sourcesContent":["import './Card.css';\n\n// This is a 'container' component which acts as a shell around other components. It has been created for UI only. Being a component, it can be used repeatedely.\n\nfunction Card(props) {\n\tconst classes = 'card ' + props.className;\n\n\treturn <div className={classes}>{props.children}</div>;\n}\n\nexport default Card;\n","import './ExpenseDate.css';\n\nfunction ExpenseDate(props) {\n\tconst month = props.date.toLocaleString('en-US', { month: 'long' });\n\n\tconst day = props.date.toLocaleString('en-US', { day: '2-digit' });\n\tconst year = props.date.getFullYear();\n\n\treturn (\n\t\t<div className='expense-date'>\n\t\t\t<div className='expense-date__month'>{month}</div>\n\t\t\t<div className='expense-date__day'>{day}</div>\n\t\t\t<div className='expense-date__year'>{year}</div>\n\t\t</div>\n\t);\n}\n\nexport default ExpenseDate;\n","import React from 'react';\nimport './ExpenseItem.css';\nimport Card from '../UI/Card';\nimport ExpenseDate from './ExpenseDate';\n\nconst ExpenseItem = (props) => {\n\treturn (\n\t\t<li>\t\t\t{/* 1 */}\n\t\t\t<Card className='expense-item'>\n\t\t\t\t<ExpenseDate date={props.date} />\n\t\t\t\t<div className='expense-item__description'>\n\t\t\t\t\t<h2>{props.title}</h2>\n\t\t\t\t</div>\n\t\t\t\t<div className='expense-item__price'>${props.amount}</div>\n\t\t\t</Card>\n\t\t</li>\n\t);\n};\n\nexport default ExpenseItem;\n\n// ! This component also happens to be a 'stateless' aka 'presentational' aka 'Dumb' component because it doesnt have any internal state. Its just there to output/ return some data\n\n/*\n!   1.\n*   Since we are rendering the 'ExpensesList' as an HTML element UL, in order to keep semantic sanctity, we should encapsulate the component <Expenseitem> as an <li>, thjeus making corresponding changes in ExpenseItem.js\n */","import React from 'react';\n\nimport './ExpensesFilter.css';\n\nconst ExpensesFilter = (props) => {\n\tconst dropDownChangeHandler = (event) => {\n\t\tconsole.log(event.target.value);\n\t\tprops.onChangeFilter(event.target.value);\n\t};\n\n\treturn (\n\t\t<div className='expenses-filter'>\n\t\t\t<div className='expenses-filter__control'>\n\t\t\t\t<label>Filter by year</label>\n\t\t\t\t<select value={props.selected} onChange={dropDownChangeHandler}>\n\t\t\t\t\t<option value='2022'>2022</option>\n\t\t\t\t\t<option value='2021'>2021</option>\n\t\t\t\t\t<option value='2020'>2020</option>\n\t\t\t\t\t<option value='2019'>2019</option>\n\t\t\t\t</select>\n\t\t\t</div>\n\t\t</div>\n\t);\n};\n\nexport default ExpensesFilter;\n\n/*\n\n*\tNote : \n\n* The ExpensesFilter.js is just a component which just constitutes to the UI and presentation of the Filter functionality. Its functionality is just limited to ccapturing the 'event', when it happens.\n* It is a component which comprises of few listeners and Props\n\n* The the 'event' is passed up as an argument to the parent component Expenses.js through the use of props, after which the selected value is recieved from the parent component to ExpensesFilter.js through the 2 way binding\n\n\n* the actual logic resides in the parent compnonet\n\n*: Both the selected value as well as the function which handles the selected value are both not part of the 'ExpensesFilter.js' but its parent component i.e. 'Expenses.js'.\n*  This is what makes ExpensesFilter.js a 'controlled component' because it is being controlled by parent component. Techanically, it doesnt make any difference anywhere BUT in the terms of understanding the mechanism, it just means that both the 'value' and the 'changes to the value' are not controlled by the component itself , but in a parent component.\n\n* 'Stateless' aka 'Presentational' aka 'Dumb' components vs 'Statefull' aka 'Smart' components\n* Stateless components are those which doesnt have any state to manage. They are those which are just there to output/ return some data.\n\n* React applications will have more such components than 'statefull' components. Generally, the state is only managed by couple of components and then passed through to other components like in this case: Expenses.js is the 'Statefull' component and then the state is passed onto through props to other compnents like ExpenseFilter.js component.\n*/\n","import React from 'react';\nimport ExpenseItem from './ExpenseItem';\nimport './ExpensesList.css'\n\nconst ExpensesList = (props) => {\n   \n \n\n    if (props.items.length === 0) {\n        return (<h2 className = \"expenses-list__fallback\">Found No Expenses</h2>)\n    }\n\t\n\n    return <ul className=\"expenses-list\">   {/* 1 */}\n        {props.items.map((i) => (\n        <ExpenseItem\n            key={i.id}\n            title={i.title}\n            date={i.date}\n            amount={i.amount}\n        />\n         ))}\n\n</ul>\n}\n\nexport default ExpensesList;\n\n/*\n!   1.\n*   Since we are rendering the 'ExpensesList' as an HTML element UL, in order to keep semantic sanctity, we should encapsulate the component <Expenseitem> as an <li>, thjeus making corresponding changes in ExpenseItem.js\n */","import React from 'react';\nimport './ChartBar.css';\n\nconst ChartBar = (props) => {\n\tlet barFillHeight = '0%'; // we have assigned a string because of it being rendered as a css dynamic style\n\n\tif (props.maxValue > 0) {\n\t\tbarFillHeight = Math.round((props.value / props.maxValue) * 100) + '%';\n\t}\n\treturn (\n\t\t<div className='chart-bar'>\n\t\t\t<div className='chart-bar__inner'>\n\t\t\t\t<div\n\t\t\t\t\tclassName='chart-bar__fill'\n\t\t\t\t\tstyle={{ height: barFillHeight }}\n\t\t\t\t></div>\n\t\t\t</div>\n\t\t\t<div className='chart-bar__label'>{props.label}</div>\n\t\t</div>\n\t);\n};\n\nexport default ChartBar;\n\n// *1 Adding style CSS dynamically:\n// Components can have style attribute which only accepts an JS object and since we are adding it dynamically, hence an extra pair of curly braces\n","import React from 'react';\nimport './Chart.css';\nimport ChartBar from './ChartBar';\n\nconst Chart = (props) => {\n\tconst dataPointValues = props.dataPoints.map((dataPoint) => dataPoint.value);\n\tconst totalMax = Math.max(...dataPointValues); //Spread Operator: spreading out the values out of the array, ..to get the maximum value out\n\treturn (\n\t\t<div className='chart'>\n\t\t\t{props.dataPoints.map((dataPoint) => (\n\t\t\t\t<ChartBar\n\t\t\t\t\tkey={dataPoint.label}\n\t\t\t\t\tvalue={dataPoint.value}\n\t\t\t\t\tlabel={dataPoint.label}\n\t\t\t\t\tmaxValue={totalMax}\n\t\t\t\t></ChartBar>\n\t\t\t))}\n\t\t</div>\n\t);\n};\n\nexport default Chart;\n","import React from 'react';\nimport Chart from '../Chart/Chart';\n\nconst ExpensesChart = (props) => {\n\tconst chartDataPoints = [\n\t\t{\n\t\t\tlabel: 'Jan',\n\t\t\tvalue: 0,\n\t\t},\n\t\t{\n\t\t\tlabel: 'Feb',\n\t\t\tvalue: 0,\n\t\t},\n\t\t{\n\t\t\tlabel: 'Mar',\n\t\t\tvalue: 0,\n\t\t},\n\t\t{\n\t\t\tlabel: 'Apr',\n\t\t\tvalue: 0,\n\t\t},\n\t\t{\n\t\t\tlabel: 'May',\n\t\t\tvalue: 0,\n\t\t},\n\t\t{\n\t\t\tlabel: 'Jun',\n\t\t\tvalue: 0,\n\t\t},\n\t\t{\n\t\t\tlabel: 'Jul',\n\t\t\tvalue: 0,\n\t\t},\n\t\t{\n\t\t\tlabel: 'Aug',\n\t\t\tvalue: 0,\n\t\t},\n\t\t{\n\t\t\tlabel: 'Sep',\n\t\t\tvalue: 0,\n\t\t},\n\t\t{\n\t\t\tlabel: 'Oct',\n\t\t\tvalue: 0,\n\t\t},\n\t\t{\n\t\t\tlabel: 'Nov',\n\t\t\tvalue: 0,\n\t\t},\n\t\t{\n\t\t\tlabel: 'Dec',\n\t\t\tvalue: 0,\n\t\t},\n\t];\n\n\tfor (const expense of props.expenses) {\n\t\tconst expenseMonth = expense.date.getMonth(); // starting at 0 ==> January => 0\n\t\tchartDataPoints[expenseMonth].value += expense.amount;\n\t}\n\n\treturn <Chart dataPoints={chartDataPoints}></Chart>;\n};\n\nexport default ExpensesChart;\n","import React, { useState } from 'react';\nimport Card from '../UI/Card';\nimport ExpenseItem from './ExpenseItem';\nimport ExpensesFilter from './ExpensesFilter';\nimport ExpensesList from './ExpensesList';\nimport ExpensesChart from './ExpensesChart';\n\nfunction Expenses(props) {\n\tconst [filteredYear, setFilteredYear] = useState('2020'); /* 1 */\n\n\tconst filterChangeHandler = (selectedYear) => {\n\t\tsetFilteredYear(selectedYear); /* 2 */\n\n\t\tconsole.log(selectedYear);\n\t};\n\n\tconst filteredExpenses = props.itemData.filter((i) => {\n\t\treturn i.date.getFullYear().toString() === filteredYear;\n\t});\n\t/* 3 */\n\n\t// **********************************\n\t/* 8  ** All of the below content has been made a seperate component - ExpensesList.js*/\n\n\t// let expensesContent = <p>No Expenses found</p>\t\t\t\t/* 7 */\n\n\t// if (filteredExpenses.length > 0) {\n\t// \texpensesContent = filteredExpenses.map((i) => {\n\n\t// \t\t\t\t\t\treturn (\n\t// \t\t\t\t\t\t\t<ExpenseItem\n\t// \t\t\t\t\t\t\t\tkey={i.id}\n\t// \t\t\t\t\t\t\t\ttitle={i.title}\n\t// \t\t\t\t\t\t\t\tdate={i.date}\n\t// \t\t\t\t\t\t\t\tamount={i.amount}\n\t// \t\t\t\t\t\t\t/>\n\t// \t\t\t\t\t\t);\n\t// \t\t\t\t\t})\n\t//\n\t// **********************************\n\n\treturn (\n\t\t<div>\n\t\t\t<Card className='expenses'>\n\t\t\t\t<ExpensesFilter\n\t\t\t\t\tselected={filteredYear}\n\t\t\t\t\tonChangeFilter={filterChangeHandler}\n\t\t\t\t/>\n\n\t\t\t\t{/* 8  ** All of the below content has been made a seperate component - ExpensesList.js*/}\n\n\t\t\t\t{/* {expensesContent}\t7 */}\n\n\t\t\t\t{/* {filteredExpenses.length === 0 && <p>No Exxxpenses to Show</p>} */}\n\t\t\t\t{/* {filteredExpenses.length > 0 && (filteredExpenses.map((i) => { */}\n\t\t\t\t{/* 4 */\n\t\t\t\t/* 6 */}\n\t\t\t\t{/* return ( */}\n\t\t\t\t{/* <ExpenseItem */}\n\t\t\t\t{/* key={i.id} */}\n\t\t\t\t{/* title={i.title} */}\n\t\t\t\t{/* date={i.date} */}\n\t\t\t\t{/* amount={i.amount} */}\n\t\t\t\t{/* /> */}\n\t\t\t\t{/* ); */}\n\t\t\t\t{/* })) */}\n\t\t\t\t<ExpensesChart expenses={filteredExpenses}></ExpensesChart>\n\n\t\t\t\t{<ExpensesList items={filteredExpenses} />}\n\t\t\t</Card>\n\t\t</div>\n\t);\n}\n\nexport default Expenses;\n\n/* 5 */\n\n/*\n!\t1.\n\n\t* The Expenses component here manages the 'filter' state hence its also called as 'Statefull' component aka 'Smart' components.\n\n \n\t* \tall React hooks can be recognosed by the preFix 'use' \n\t* \tHooks can only be called directly within the component function and not outside. Also before the return statement. calling it after return statement would make it redundant and wouldnt make any sense\n\t*\tReact hooks are functions\n\t*\tHooks can never be used within a nested function. like in  here, they cannot be used within 'filterChangeHandler'\n\t* \tuseState() doesnt just work by itself. it NEEDS an INITIAL value. Any changes to this value (any changes to this current STATE) will make the component function to be called again and thus we should define that initial value to that variable.\n\t*\tuseState() HOOK ALWAYS RETURNS an ARRAY comprising of EXACTLY 2 elements. The 1st element gives access to the VARIABLE VALUE ITSELF and the second is an FUNCTION which is used to change the value and trigger a re-EVALUATION of the component itself.\n\t* \tThe 1st element is just a pointer to that managed value (the current value which could be '' or initial value set by us, e.g '2020' as seen above) and the second element is the function named above as setFilteredYear which is used to change that initial value\n\t*\tThis function will do 2 things: 1st it will assign a new value (the arguemnt that is being passed) to the STATE aka the variable 'filteredYear' . 2nd, It'll also trigger REACT to re-EVALUATE the entire component again, thereby resetting all places where the state was being used, with the new value of the STATE. React will observe any changes it detects compared from the last time it evaluated this component and shows it on to the screen.\n\n\n\t* \tWhen to use hook - useState?\n   \n   \t*\tIf you have data which might change and where that change needs to be reflected to the UI, Then we need STATE because regular variables will not do  the trick however with STATE variable, you can use a function which NOT only change the initial value of the state but ALSO trigger a re-EVALUATION of the entire component. Even if there would be multiple components, this re-evaluation only happens for the component in which this STATE was registered, and no other. \n\t*/\n\n/*\n !\t2.\nThis function will do 2 things: 1st it will assign a new value(the arguemnt that is being passed) to the STATE aka the variable 'filteredYear'. 2nd, It'll also trigger REACT to re-EVALUATE the entire component again, thereby resetting all places where the state was being used, with the new value of the STATE\n\t\tReact will observe any changes it detects compared from the last time is evaluated this component and shows it on to the screen\n*  calling the setFilteredYear () MAY not change the value right away but rather SCHEDULES this STATE UPDATE to be executed and implemented post the re-EVALUATION cycle.\n*/\n\n/* \n\t !\t3\n\t *\tThe above function filters and gives a new array with the items that qualified for the condition passed in funtion form, as an argument. It doesnt effects the original array.\n\t */\n\n/*\n\t !\t4.\n\t  \n\t* Using array.map(), we are transforming each item in the array 'props.itemData, to a new array with each item having trasnformed into a JSX elements...Thus handling it dyna,ically */\n\n/*\n!\t5.\n\n* 'Stateless' aka 'Presentational' aka 'Dumb' components vs 'Statefull' aka 'Smart' components\n* Stateless components are those which doesnt have any state to manage. They are those which are just there to output/ return some data.\n* React applications will have more such components than 'statefull' components. Generally, the state is only managed by couple of components and then passed through to other components like in this case: Expenses.js is the 'Statefull' component and then the state is passed onto through props to other compnents like ExpenseFilter.js component.\n\n/*\nKey prop (with its value equivalent to a unique ID) has been added as to ensure React recognises which specific element in the list should it be updating rather than, having React to work itself and scan the entire long list and seek which element has been added off late. \n\nThough this key prop can be added anywhere but it should definately be added where you are RENDERING the LIST. like in this instance in the Expenses.js because its here that the component 'Expenses' is being defined within which the LIST gets rendered.\n\nThis is effecient and time saving as React would not have to unnecessary scan the list \nMost of the times, when dealing with databases, we should be able to identify which should be that unique ID that can be used as a 'key' for React to make use of it for unique identification. But in case, no unique ID is available, then we can provide 'index' as a second arguement in map which then can be used in place of 'id'.\n\n\nprops.itemData.map((i,index) => {\n\t\t\t\t\n\t\t\t\t\treturn (\n\t\t\t\t\t\t<ExpenseItem\n\t\t\t\t\t\t\tkey={i.index}\n\t\t\t\t\t\t\ttitle={i.title}\n\t\t\t\t\t\t\tdate={i.date}\n\t\t\t\t\t\t\tamount={i.amount}\n\t\t\t\t\t\t/>\n\t\t\t\t\t);\n\t\t\t\t})}\n */\n\n/*\n!\t6.\n*\tImplementing a condition which can be done in either of below ways:\n\t\n\t*\tThe use of Ternerary operator instead of usual 'conditional' statements:\n\t{filteredExpenses.length===0?(<p>There is no Expense to show</p>):(\n\tfilteredExpenses.map((i)=>{\n\t\treturn (\n\t\t\t<Expense Item \n\t\t\tkey = {i.id} \n\t\t\ttitle={i.title}\n\t\t\tamount = {i.amount}\n\t\t\tdate = {i.date}\n\t\t\t/> \n\t\t\t))}\n\t)}\n\n\t*\tOr else use of '&&' operator: \n\t\t\tIf the first condition in first line is true, then the follow up instruction after '&&' gets executed. Else, the second line condition gets checked and the follow up instruction gets executed.\n   \n\t\t\t{filteredYear.length === 0 && (<p>There is No expense</p>)}\n\t\t\t{filteredYear.length > 0 && (filteredExpenses.map((i)=>{\n\t\treturn (\n\t\t\t<Expense Item \n\t\t\tkey = {i.id} \n\t\t\ttitle={i.title}\n\t\t\tamount = {i.amount}\n\t\t\tdate = {i.date}\n\t\t\t/> \n\t\t\t))})}\n\n\t*\tOr refer to the point 7\t\t\n*/\n\n/*\n!\t7. \n*\tOnly the calculated value of expensesContent gets through to here. All the conbdional aspect has been taken care off outside of the component return statement\n\n */\n\n/*\n! 8. \n*\tThe conditional part has been made a seperate <ExpensesList/> component \n*/\n","import React, { useState } from 'react';\nimport './ExpenseForm.css';\n\nconst ExpenseForm = (props) => {\n\tconst [enteredTitle, setEnteredTitle] = useState('');\n\tconst [enteredAmount, setEnteredAmount] = useState('');\n\tconst [enteredDate, setEnteredDate] = useState(''); /* 1 */\n\n\tconst titleChangeHandler = (event) => {\n\t\tsetEnteredTitle(event.target.value); /* 2 */\n\t\tconsole.log(event.target.value);\n\t};\n\n\tconst amountChangeHandler = (event) => {\n\t\tsetEnteredAmount(event.target.value);\n\t\tconsole.log(event.target.value);\n\t};\n\tconst dateChangeHandler = (event) => {\n\t\tsetEnteredDate(event.target.value);\n\t};\n\n\t/* 3 */\n\n\tconst submitHandler = (event) => {\n\t\tevent.preventDefault();\n\n\t\tconst expenseData = {\n\t\t\ttitle: enteredTitle,\n\t\t\tamount: +enteredAmount,\n\t\t\tdate: new Date(enteredDate),\n\t\t};\n\t\tconsole.log(expenseData);\n\t\tprops.onSaveExpenseData(expenseData);\n\t\tsetEnteredTitle('');\n\t\tsetEnteredAmount('');\n\t\tsetEnteredDate('');\n\t};\n\t/* 4 */\n\n\treturn (\n\t\t<div>\n\t\t\t<form onSubmit={submitHandler}>\n\t\t\t\t<div className='new-expense__controls'>\n\t\t\t\t\t<div className='new-expense__control'>\n\t\t\t\t\t\t<label>Title</label>\n\t\t\t\t\t\t<input\n\t\t\t\t\t\t\ttype='text'\n\t\t\t\t\t\t\tvalue={enteredTitle}\n\t\t\t\t\t\t\tonChange={titleChangeHandler}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className='new-expense__control'>\n\t\t\t\t\t\t<label>Amount</label>\n\t\t\t\t\t\t<input\n\t\t\t\t\t\t\ttype='number'\n\t\t\t\t\t\t\tmin='0.01'\n\t\t\t\t\t\t\tstep='0.01'\n\t\t\t\t\t\t\tvalue={enteredAmount}\n\t\t\t\t\t\t\tonChange={amountChangeHandler}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className='new-expense__control'>\n\t\t\t\t\t\t<label>Date</label>\n\t\t\t\t\t\t<input\n\t\t\t\t\t\t\ttype='date'\n\t\t\t\t\t\t\tmin='2019-01-01'\n\t\t\t\t\t\t\tmax='2022-12-31'\n\t\t\t\t\t\t\tvalue={enteredDate}\n\t\t\t\t\t\t\tonChange={dateChangeHandler}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div className='new-expense__actions'>\n\t\t\t\t\t<button type='submit'>Add Expenses</button>\n\t\t\t\t</div>\n\t\t\t</form>\n\t\t</div>\n\t);\n};\n\n/* 5 */\nexport default ExpenseForm;\n\n/*\n*  NOTES ----\n\n!\t1.\t\n\t* We can use multiple useState statements\n\n\t*\tWe can use and have multiple State slices or useState pieces per component. And then, all these multiple different states would then also be totally seperated and independent of  each other.\n\t*\tThe above 3 state slices would not impact each other while we use them.\n\t\n\t* The ExpenseForm.js component here manages the 'input' state\n\t* The state recieves an (optional) state value as an argument.\n\t* Calling 'useState' again will NOT update the state value but will simply create a new state.\n\t* useState always returns an array with exactly two elements - 1st element captures initial state value; 2nd element is a function that can be called to set a new value for the 'state'. Calling that function also triggers React to re-valuate the component.\n*/\n\n/*\n!\t2.\t \n\t*\tThough setEnteredTitle(): would update and store the new value in 'enteredTitle' state; our intention at this point is to use it to capture temporarily the value being entered by the user. This is a good way to log snaps of subsequent values that will be entered. The aim is to have a way to store the subsequent values in a variable which is also detached to the entire lifecycle of this very component function, so that not matter how often  this component function will execute again, this state is stored and survives the reexecutions .\n\n\t* The aim is to have the user enetered value captured in through the setEnteredTitile function and then call the function again with ('') parameters but only after having an object created to permanently store the values user entered in the first place.\n\n\t* This type of functionality is important when you'd like to reset the blanks to thier initial values.\n */\n\n/*\n!\t3.\t\n\t*\tALso, we could have alternatiely used a single object approach instead of the multiple slices approach as seen above.\n\tBut then we need to be mindfull of the approach by which we update the previous state with the user's new Value.\n\n\tconst [userInput, setUserInput] = useState({\n\t \tenteredTitle: '',\n\t \tenteredAmount: '',\n\t \tenteredDate: '',\n\t });\n\n\t*\tThe SYNTAX to follow when our state update is based the previous state (another e.g. could be like in case of number increment)\n\t, When updating new State based on past state, It could happen that React picks up a wrong past state, just because the new updates are scheduled for future when using setEnteredTitle()\n\tThus to ensure, React picks up the latest previous State and not some distant previuos state, use the beloow \"Function form\" syntax:\n\tWhere prevState is passed as an arguement by React\n\n\n BAD SYNTAX\n\nsetEnteredTitle({\n\t...prevState,\n\tenteredTitle:event.target.value\n})\n\n\nGOOD SYNTAX: \t\nsetEnteredTitle((prevState)=>{\nreturn {...prevState, enteredTitle:event.target.value}\n})\n\nAn anonymous arrow function is being passed Where: prevStat points to the object and its 'state' as defined above.\n*/\n\n/*\n !\t4.\t\n \t* 2 way binding: We not only listen to changes in the input to update our state (through setEnteredTitle()) but we also feed the state(variable) back into the input(through default attribute 'value'), so that when we change the state, it is followed by change in the input automatically, hence the term '2 way binding'.\n\t\n\t* 2 way binding: means that for 'input's, we are not only listening for changes BUT ALSO, we can pass a new value back into the input, Hence changing the input value programatically.\n*/\n\n/*\n!\t5. \n\t/* \n* We can create our own event props, where we expect functions as values and that would allow us to pass a function from a PARENT component to a CHILD component, and then call that function inside of a CHILD component. \n\n* and then, when we call that component, we can ofcourse pass data to this function as a parameter, and that's how we can communincate up...from CHILD to PARENT.\n*/\n","// *Adding a form - for recieving user Inputs\n\nimport React from 'react';\nimport './NewExpense.css';\nimport ExpenseForm from './ExpenseForm';\n\nconst NewExpense = (props) => {\n\tconst saveExpenseDataHandler = (enteredExpenseDataPlaceHolder) => {\n\t\tconst expenseData = {\n\t\t\t...enteredExpenseDataPlaceHolder,\n\t\t\tid: Math.random().toString(),\n\t\t};\n\t\tconsole.log(expenseData);\n\t\tprops.onAddExpense(expenseData);\n\t};\n\n\treturn (\n\t\t<div className='new-expense'>\n\t\t\t<ExpenseForm onSaveExpenseData={saveExpenseDataHandler}></ExpenseForm>\n\t\t\t{/* 1 */}\n\t\t</div>\n\t);\n};\n\nexport default NewExpense;\n\n/* \n!\t1.\n\n* we are not executing the function 'saveExpenseDatahandler' above but rather just point to the function (which has also been defined a little over above)\n* The funcction itself or the pointer to this function gets passed to the CHILD component 'ExpenseForm ' and then the function gets executed there, with the data that resides there, being passed as an arguement \n\t\t\t\n* This way, the data can be passed over from a CHILD to a PARENT component*/\n","import React, { useState } from 'react';\nimport Expenses from './components/Expenses/Expenses';\nimport './components/Expenses/Expenses.css';\nimport NewExpense from './components/NewExpense/NewExpense';\n\nconst Dummy_Expenses = [\n\t{\n\t\tid: 'e1',\n\t\ttitle: 'Toilet Paper',\n\t\tamount: 94.12,\n\t\tdate: new Date(2020, 7, 14),\n\t},\n\t{ id: 'e2', title: 'New TV', amount: 799.49, date: new Date(2021, 2, 12) },\n\t{\n\t\tid: 'e3',\n\t\ttitle: 'Car Insurance',\n\t\tamount: 294.67,\n\t\tdate: new Date(2021, 2, 28),\n\t},\n\t{\n\t\tid: 'e4',\n\t\ttitle: 'New Desk (Wooden)',\n\t\tamount: 450,\n\t\tdate: new Date(2021, 5, 12),\n\t},\n\t{\n\t\tid: 'e5',\n\t\ttitle: 'Mac Computer',\n\t\tamount: 1990,\n\t\tdate: new Date(2021, 12, 24),\n\t},\n];\nconst App = () => {\n\tconst [expenses, setExpenses] = useState(Dummy_Expenses);\n\n\tconst addExpenseHandler = (placeHolderItem) => {\n\t\t// setExpenses([placeHolderItem, ...expenses]);  /* *This is not the most approporiate way, refer to the below alternative */\n\t\tsetExpenses((prevSnapshot) => {\n\t\t\treturn [placeHolderItem, ...prevSnapshot];\n\t\t});\n\t};\n\treturn (\n\t\t<div>\n\t\t\t<NewExpense onAddExpense={addExpenseHandler}></NewExpense>\n\t\t\t<div className='expenses'>\n\t\t\t\t<Expenses itemData={expenses} />\n\t\t\t</div>\n\t\t</div>\n\t);\n};\n\nexport default App;\n\n/*\n * If a new expense record(initiated in ExpenseForm.js and flowing through NewExpense.js, ) has to be added to the existing array \"Dummy_Expenses\", It has to be through state management since amending the variable simply(Daummy_Expenses) would not be registered in React environement.\n * Thus, we capture the existing snapshot of the state in 'expenses'\n * and then for adding an instance of a new Expense, we use setExpense().\n * ALSO since our new snapshot of the state shall be based on previous snapshot of this state(aka react variable), we need to pass a function with prevSnapshot being the arguement.\n * This way, React ensures it only picks the latest previous snapshot to update the variable (aka state) with new records/ updates.\n */\n","import ReactDOM from 'react-dom';\n\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}